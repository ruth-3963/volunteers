{"ast":null,"code":"import { IntlBase as base } from './intl-base';\nimport { ParserBase as parser } from './parser-base';\nimport { isUndefined, throwError, getValue, isNullOrUndefined, isBlazor } from '../util';\nimport { datePartMatcher } from './date-formatter';\nimport { HijriParser } from '../hijri-parser';\nvar number = 'numbers';\nvar defNoSystem = 'defaultNumberingSystem';\nvar noSystem = 'numberingSystem';\nvar standalone = 'stand-alone';\nvar curWeekDay = 'curWeekDay';\nvar latnRegex = /^[0-9]*$/;\nvar abbreviateRegex = /\\/MMMMM|MMMM|MMM|a|LLLL|LLL|EEEEE|EEEE|E|ccc/;\nvar timeSetter = {\n  minute: 'setMinutes',\n  hour: 'setHours',\n  second: 'setSeconds',\n  day: 'setDate',\n  month: 'setMonth',\n  milliseconds: 'setMilliseconds'\n};\nvar month = 'months';\n/* tslint:disable no-any */\n\n/**\r\n * Date Parser.\r\n * @private\r\n */\n\nvar DateParser =\n/** @class */\nfunction () {\n  function DateParser() {}\n  /**\r\n   * Returns the parser function for given skeleton.\r\n   * @param {string} -  Specifies the culture name to be which formatting.\r\n   * @param {DateFormatOptions} - Specific the format in which string date  will be parsed.\r\n   * @param {cldr} - Specifies the global cldr data collection.\r\n   *  @return Function.\r\n   */\n  // tslint:disable-next-line:max-func-body-length\n\n\n  DateParser.dateParser = function (culture, option, cldr) {\n    var _this = this;\n\n    var dependable = base.getDependables(cldr, culture, option.calendar); // tslint:disable-next-line\n\n    var numOptions = parser.getCurrentNumericOptions(dependable.parserObject, parser.getNumberingSystem(cldr), false, isBlazor());\n    var parseOptions = {};\n\n    if (isBlazor() && option.isServerRendered) {\n      option = base.compareBlazorDateFormats(option, culture);\n    }\n\n    var resPattern = option.format || base.getResultantPattern(option.skeleton, dependable.dateObject, option.type, false, isBlazor() ? culture : '');\n    var regexString = '';\n    var hourOnly;\n\n    if (isUndefined(resPattern)) {\n      throwError('Format options or type given must be invalid');\n    } else {\n      resPattern = base.ConvertDateToWeekFormat(resPattern);\n      parseOptions = {\n        isIslamic: base.islamicRegex.test(option.calendar),\n        pattern: resPattern,\n        evalposition: {},\n        culture: culture\n      };\n      var patternMatch = resPattern.match(base.dateParseRegex) || [];\n      var length_1 = patternMatch.length;\n      var gmtCorrection = 0;\n      var zCorrectTemp = 0;\n      var isgmtTraversed = false;\n      var nRegx = numOptions.numericRegex; // tslint:disable-next-line\n\n      var numMapper = isBlazor() ? dependable.parserObject.numbers : parser.getNumberMapper(dependable.parserObject, parser.getNumberingSystem(cldr));\n\n      for (var i = 0; i < length_1; i++) {\n        var str = patternMatch[i];\n        var len = str.length;\n        var char = str[0] === 'K' ? 'h' : str[0];\n        var isNumber = void 0;\n        var canUpdate = void 0; // tslint:disable-next-line\n\n        var charKey = datePartMatcher[char];\n        var optional = len === 2 ? '' : '?';\n\n        if (isgmtTraversed) {\n          gmtCorrection = zCorrectTemp;\n          isgmtTraversed = false;\n        }\n\n        switch (char) {\n          case 'E':\n          case 'c':\n            // tslint:disable\n            var weekData = void 0;\n\n            if (isBlazor()) {\n              weekData = getValue('days.' + base.monthIndex[len], dependable.dateObject);\n            } else {\n              weekData = dependable.dateObject[base.days][standalone][base.monthIndex[len]];\n            }\n\n            var weekObject = parser.reverseObject(weekData); // tslint:enable\n\n            regexString += '(' + Object.keys(weekObject).join('|') + ')';\n            break;\n\n          case 'M':\n          case 'L':\n          case 'd':\n          case 'm':\n          case 's':\n          case 'h':\n          case 'H':\n          case 'f':\n            canUpdate = true;\n\n            if ((char === 'M' || char === 'L') && len > 2) {\n              var monthData = void 0;\n\n              if (isBlazor()) {\n                /* tslint:disable no-any */\n                monthData = getValue('months.' + base.monthIndex[len], dependable.dateObject);\n              } else {\n                /* tslint:disable no-any */\n                monthData = dependable.dateObject[month][standalone][base.monthIndex[len]];\n              } // tslint:disable-next-line\n\n\n              parseOptions[charKey] = parser.reverseObject(monthData);\n              /* tslint:disable no-any */\n\n              regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + ')';\n            } else if (char === 'f') {\n              if (len > 3) {\n                continue;\n              }\n\n              isNumber = true;\n              regexString += '(' + nRegx + nRegx + '?' + nRegx + '?' + ')';\n            } else {\n              isNumber = true;\n              regexString += '(' + nRegx + nRegx + optional + ')';\n            }\n\n            if (char === 'h') {\n              parseOptions.hour12 = true;\n            }\n\n            break;\n\n          case 'W':\n            var opt = len === 1 ? '?' : '';\n            regexString += '(' + nRegx + opt + nRegx + ')';\n            break;\n\n          case 'y':\n            canUpdate = isNumber = true;\n\n            if (len === 2) {\n              regexString += '(' + nRegx + nRegx + ')';\n            } else {\n              regexString += '(' + nRegx + '{' + len + ',})';\n            }\n\n            break;\n\n          case 'a':\n            canUpdate = true;\n            var periodValur = isBlazor() ? getValue('dayPeriods', dependable.dateObject) : getValue('dayPeriods.format.wide', dependable.dateObject);\n            parseOptions[charKey] = parser.reverseObject(periodValur);\n            regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + ')';\n            break;\n\n          case 'G':\n            canUpdate = true;\n            var eText = len <= 3 ? 'eraAbbr' : len === 4 ? 'eraNames' : 'eraNarrow';\n            parseOptions[charKey] = parser.reverseObject(isBlazor() ? getValue('eras', dependable.dateObject) : getValue('eras.' + eText, dependable.dateObject));\n            regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + '?)';\n            break;\n\n          case 'z':\n            var tval = new Date().getTimezoneOffset();\n            canUpdate = tval !== 0;\n            parseOptions[charKey] = getValue('dates.timeZoneNames', dependable.parserObject);\n            var tzone = parseOptions[charKey];\n            hourOnly = len < 4;\n            var hpattern = hourOnly ? '+H;-H' : tzone.hourFormat;\n            hpattern = hpattern.replace(/:/g, numMapper.timeSeparator);\n            regexString += '(' + this.parseTimeZoneRegx(hpattern, tzone, nRegx) + ')?';\n            isgmtTraversed = true;\n            zCorrectTemp = hourOnly ? 6 : 12;\n            break;\n\n          case '\\'':\n            var iString = str.replace(/\\'/g, '');\n            regexString += '(' + iString + ')?';\n            break;\n\n          default:\n            regexString += '([\\\\D])';\n            break;\n        }\n\n        if (canUpdate) {\n          parseOptions.evalposition[charKey] = {\n            isNumber: isNumber,\n            pos: i + 1 + gmtCorrection,\n            hourOnly: hourOnly\n          };\n        }\n\n        if (i === length_1 - 1 && !isNullOrUndefined(regexString)) {\n          parseOptions.parserRegex = new RegExp('^' + regexString + '$', 'i');\n        }\n      }\n    }\n\n    return function (value) {\n      var parsedDateParts = _this.internalDateParse(value, parseOptions, numOptions);\n\n      if (isNullOrUndefined(parsedDateParts) || !Object.keys(parsedDateParts).length) {\n        return null;\n      }\n\n      if (parseOptions.isIslamic) {\n        var dobj = {};\n        var tYear = parsedDateParts.year;\n        var tDate = parsedDateParts.day;\n        var tMonth = parsedDateParts.month;\n        var ystrig = tYear ? tYear + '' : '';\n        var is2DigitYear = ystrig.length === 2;\n\n        if (!tYear || !tMonth || !tDate || is2DigitYear) {\n          dobj = HijriParser.getHijriDate(new Date());\n        }\n\n        if (is2DigitYear) {\n          tYear = parseInt((dobj.year + '').slice(0, 2) + ystrig, 10);\n        } // tslint:disable-next-line\n\n\n        var dateObject = HijriParser.toGregorian(tYear || dobj.year, tMonth || dobj.month, tDate || dobj.date);\n        parsedDateParts.year = dateObject.getFullYear();\n        parsedDateParts.month = dateObject.getMonth() + 1;\n        parsedDateParts.day = dateObject.getDate();\n      }\n\n      return _this.getDateObject(parsedDateParts);\n    };\n  };\n  /* tslint:disable */\n\n  /**\r\n   * Returns date object for provided date options\r\n   * @param {DateParts} options\r\n   * @param {Date} value\r\n   * @returns {Date}\r\n   */\n\n\n  DateParser.getDateObject = function (options, value) {\n    var res = value || new Date();\n    res.setMilliseconds(0);\n    var tKeys = ['hour', 'minute', 'second', 'milliseconds', 'month', 'day'];\n    var y = options.year;\n    var desig = options.designator;\n    var tzone = options.timeZone;\n\n    if (!isUndefined(y)) {\n      var len = (y + '').length;\n\n      if (len <= 2) {\n        var century = Math.floor(res.getFullYear() / 100) * 100;\n        y += century;\n      }\n\n      res.setFullYear(y);\n    }\n\n    for (var _i = 0, tKeys_1 = tKeys; _i < tKeys_1.length; _i++) {\n      var key = tKeys_1[_i];\n      var tValue = options[key];\n\n      if (isUndefined(tValue) && key === \"day\") {\n        res.setDate(1);\n      }\n\n      if (!isUndefined(tValue)) {\n        if (key === 'month') {\n          tValue -= 1;\n\n          if (tValue < 0 || tValue > 11) {\n            return new Date('invalid');\n          }\n\n          var pDate = res.getDate();\n          res.setDate(1);\n          res[timeSetter[key]](tValue);\n          var lDate = new Date(res.getFullYear(), tValue + 1, 0).getDate();\n          res.setDate(pDate < lDate ? pDate : lDate);\n        } else {\n          if (key === 'day') {\n            var lastDay = new Date(res.getFullYear(), res.getMonth() + 1, 0).getDate();\n\n            if (tValue < 1 || tValue > lastDay) {\n              return null;\n            }\n          }\n\n          res[timeSetter[key]](tValue);\n        }\n      }\n    }\n\n    if (!isUndefined(desig)) {\n      var hour = res.getHours();\n\n      if (desig === 'pm') {\n        res.setHours(hour + (hour === 12 ? 0 : 12));\n      } else if (hour === 12) {\n        res.setHours(0);\n      }\n    }\n\n    if (!isUndefined(tzone)) {\n      var tzValue = tzone - res.getTimezoneOffset();\n\n      if (tzValue !== 0) {\n        res.setMinutes(res.getMinutes() + tzValue);\n      }\n    }\n\n    return res;\n  };\n  /**\r\n   * Returns date parsing options for provided value along with parse and numeric options\r\n   * @param {string} value\r\n   * @param {ParseOptions} parseOptions\r\n   * @param {NumericOptions} num\r\n   * @returns {DateParts}\r\n   */\n\n\n  DateParser.internalDateParse = function (value, parseOptions, num) {\n    var matches = value.match(parseOptions.parserRegex);\n    var retOptions = {\n      'hour': 0,\n      'minute': 0,\n      'second': 0\n    };\n    var nRegx = num.numericRegex;\n\n    if (isNullOrUndefined(matches)) {\n      return null;\n    } else {\n      var props = Object.keys(parseOptions.evalposition);\n\n      for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {\n        var prop = props_1[_i];\n        var curObject = parseOptions.evalposition[prop];\n        var matchString = matches[curObject.pos];\n\n        if (curObject.isNumber) {\n          retOptions[prop] = this.internalNumberParser(matchString, num);\n        } else {\n          if (prop === 'timeZone' && !isUndefined(matchString)) {\n            var pos = curObject.pos;\n            var val = void 0;\n            var tmatch = matches[pos + 1];\n            var flag = !isUndefined(tmatch);\n\n            if (curObject.hourOnly) {\n              val = this.getZoneValue(flag, tmatch, matches[pos + 4], num) * 60;\n            } else {\n              val = this.getZoneValue(flag, tmatch, matches[pos + 7], num) * 60;\n              val += this.getZoneValue(flag, matches[pos + 4], matches[pos + 10], num);\n            }\n\n            if (!isNullOrUndefined(val)) {\n              retOptions[prop] = val;\n            }\n          } else {\n            matchString = prop === 'month' && !parseOptions.isIslamic && (parseOptions.culture === 'en' || parseOptions.culture === 'en-GB' || parseOptions.culture === 'en-US') ? matchString[0].toUpperCase() + matchString.substring(1).toLowerCase() : matchString;\n            retOptions[prop] = parseOptions[prop][matchString];\n          }\n        }\n      }\n\n      if (parseOptions.hour12) {\n        retOptions.hour12 = true;\n      }\n    }\n\n    return retOptions;\n  };\n  /**\r\n   * Returns parsed number for provided Numeric string and Numeric Options\r\n   * @param {string} value\r\n   * @param {NumericOptions} option\r\n   * @returns {number}\r\n   */\n\n\n  DateParser.internalNumberParser = function (value, option) {\n    value = parser.convertValueParts(value, option.numberParseRegex, option.numericPair);\n\n    if (latnRegex.test(value)) {\n      return +value;\n    }\n\n    return null;\n  };\n  /**\r\n   * Returns parsed time zone RegExp for provided hour format and time zone\r\n   * @param {string} hourFormat\r\n   * @param {base.TimeZoneOptions} tZone\r\n   * @param {string} nRegex\r\n   * @returns {string}\r\n   */\n\n\n  DateParser.parseTimeZoneRegx = function (hourFormat, tZone, nRegex) {\n    var pattern = tZone.gmtFormat;\n    var ret;\n    var result;\n    var cRegex = '(' + nRegex + ')' + '(' + nRegex + ')';\n    var splitStr;\n    ret = hourFormat.replace('+', '\\\\+');\n\n    if (hourFormat.indexOf('HH') !== -1) {\n      ret = ret.replace(/HH|mm/g, '(' + cRegex + ')');\n    } else {\n      ret = ret.replace(/H|m/g, '(' + cRegex + '?)');\n    }\n\n    splitStr = ret.split(';').map(function (str) {\n      return pattern.replace('{0}', str);\n    });\n    ret = splitStr.join('|') + '|' + tZone.gmtZeroFormat;\n    return ret;\n  };\n  /**\r\n   * Returns zone based value.\r\n   * @param {boolean} flag\r\n   * @param {string} val1\r\n   * @param {string} val2\r\n   * @param {NumericOptions} num\r\n   * @returns {number}\r\n   */\n\n\n  DateParser.getZoneValue = function (flag, val1, val2, num) {\n    var ival = flag ? val1 : val2;\n\n    if (!ival) {\n      return 0;\n    }\n\n    var value = this.internalNumberParser(ival, num);\n\n    if (flag) {\n      return -value;\n    }\n\n    return value;\n  };\n\n  return DateParser;\n}();\n\nexport { DateParser };\n/* tslint:enable */","map":{"version":3,"sources":["C:/Users/User/volunteers/node_modules/@syncfusion/ej2-react-buttons/node_modules/@syncfusion/ej2-base/src/intl/date-parser.js"],"names":["IntlBase","base","ParserBase","parser","isUndefined","throwError","getValue","isNullOrUndefined","isBlazor","datePartMatcher","HijriParser","number","defNoSystem","noSystem","standalone","curWeekDay","latnRegex","abbreviateRegex","timeSetter","minute","hour","second","day","month","milliseconds","DateParser","dateParser","culture","option","cldr","_this","dependable","getDependables","calendar","numOptions","getCurrentNumericOptions","parserObject","getNumberingSystem","parseOptions","isServerRendered","compareBlazorDateFormats","resPattern","format","getResultantPattern","skeleton","dateObject","type","regexString","hourOnly","ConvertDateToWeekFormat","isIslamic","islamicRegex","test","pattern","evalposition","patternMatch","match","dateParseRegex","length_1","length","gmtCorrection","zCorrectTemp","isgmtTraversed","nRegx","numericRegex","numMapper","numbers","getNumberMapper","i","str","len","char","isNumber","canUpdate","charKey","optional","weekData","monthIndex","days","weekObject","reverseObject","Object","keys","join","monthData","hour12","opt","periodValur","eText","tval","Date","getTimezoneOffset","tzone","hpattern","hourFormat","replace","timeSeparator","parseTimeZoneRegx","iString","pos","parserRegex","RegExp","value","parsedDateParts","internalDateParse","dobj","tYear","year","tDate","tMonth","ystrig","is2DigitYear","getHijriDate","parseInt","slice","toGregorian","date","getFullYear","getMonth","getDate","getDateObject","options","res","setMilliseconds","tKeys","y","desig","designator","timeZone","century","Math","floor","setFullYear","_i","tKeys_1","key","tValue","setDate","pDate","lDate","lastDay","getHours","setHours","tzValue","setMinutes","getMinutes","num","matches","retOptions","props","props_1","prop","curObject","matchString","internalNumberParser","val","tmatch","flag","getZoneValue","toUpperCase","substring","toLowerCase","convertValueParts","numberParseRegex","numericPair","tZone","nRegex","gmtFormat","ret","result","cRegex","splitStr","indexOf","split","map","gmtZeroFormat","val1","val2","ival"],"mappings":"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","sourcesContent":["import { IntlBase as base } from './intl-base';\r\nimport { ParserBase as parser } from './parser-base';\r\nimport { isUndefined, throwError, getValue, isNullOrUndefined, isBlazor } from '../util';\r\nimport { datePartMatcher } from './date-formatter';\r\nimport { HijriParser } from '../hijri-parser';\r\nvar number = 'numbers';\r\nvar defNoSystem = 'defaultNumberingSystem';\r\nvar noSystem = 'numberingSystem';\r\nvar standalone = 'stand-alone';\r\nvar curWeekDay = 'curWeekDay';\r\nvar latnRegex = /^[0-9]*$/;\r\nvar abbreviateRegex = /\\/MMMMM|MMMM|MMM|a|LLLL|LLL|EEEEE|EEEE|E|ccc/;\r\nvar timeSetter = {\r\n    minute: 'setMinutes',\r\n    hour: 'setHours',\r\n    second: 'setSeconds',\r\n    day: 'setDate',\r\n    month: 'setMonth',\r\n    milliseconds: 'setMilliseconds'\r\n};\r\nvar month = 'months';\r\n/* tslint:disable no-any */\r\n/**\r\n * Date Parser.\r\n * @private\r\n */\r\nvar DateParser = /** @class */ (function () {\r\n    function DateParser() {\r\n    }\r\n    /**\r\n     * Returns the parser function for given skeleton.\r\n     * @param {string} -  Specifies the culture name to be which formatting.\r\n     * @param {DateFormatOptions} - Specific the format in which string date  will be parsed.\r\n     * @param {cldr} - Specifies the global cldr data collection.\r\n     *  @return Function.\r\n     */\r\n    // tslint:disable-next-line:max-func-body-length\r\n    DateParser.dateParser = function (culture, option, cldr) {\r\n        var _this = this;\r\n        var dependable = base.getDependables(cldr, culture, option.calendar);\r\n        // tslint:disable-next-line\r\n        var numOptions = parser.getCurrentNumericOptions(dependable.parserObject, parser.getNumberingSystem(cldr), false, isBlazor());\r\n        var parseOptions = {};\r\n        if (isBlazor() && option.isServerRendered) {\r\n            option = base.compareBlazorDateFormats(option, culture);\r\n        }\r\n        var resPattern = option.format ||\r\n            base.getResultantPattern(option.skeleton, dependable.dateObject, option.type, false, isBlazor() ? culture : '');\r\n        var regexString = '';\r\n        var hourOnly;\r\n        if (isUndefined(resPattern)) {\r\n            throwError('Format options or type given must be invalid');\r\n        }\r\n        else {\r\n            resPattern = base.ConvertDateToWeekFormat(resPattern);\r\n            parseOptions = { isIslamic: base.islamicRegex.test(option.calendar), pattern: resPattern, evalposition: {}, culture: culture };\r\n            var patternMatch = resPattern.match(base.dateParseRegex) || [];\r\n            var length_1 = patternMatch.length;\r\n            var gmtCorrection = 0;\r\n            var zCorrectTemp = 0;\r\n            var isgmtTraversed = false;\r\n            var nRegx = numOptions.numericRegex;\r\n            // tslint:disable-next-line\r\n            var numMapper = isBlazor() ? dependable.parserObject.numbers :\r\n                parser.getNumberMapper(dependable.parserObject, parser.getNumberingSystem(cldr));\r\n            for (var i = 0; i < length_1; i++) {\r\n                var str = patternMatch[i];\r\n                var len = str.length;\r\n                var char = (str[0] === 'K') ? 'h' : str[0];\r\n                var isNumber = void 0;\r\n                var canUpdate = void 0;\r\n                // tslint:disable-next-line\r\n                var charKey = datePartMatcher[char];\r\n                var optional = (len === 2) ? '' : '?';\r\n                if (isgmtTraversed) {\r\n                    gmtCorrection = zCorrectTemp;\r\n                    isgmtTraversed = false;\r\n                }\r\n                switch (char) {\r\n                    case 'E':\r\n                    case 'c':\r\n                        // tslint:disable\r\n                        var weekData = void 0;\r\n                        if (isBlazor()) {\r\n                            weekData = getValue('days.' + base.monthIndex[len], dependable.dateObject);\r\n                        }\r\n                        else {\r\n                            weekData = dependable.dateObject[base.days][standalone][base.monthIndex[len]];\r\n                        }\r\n                        var weekObject = parser.reverseObject(weekData);\r\n                        // tslint:enable\r\n                        regexString += '(' + Object.keys(weekObject).join('|') + ')';\r\n                        break;\r\n                    case 'M':\r\n                    case 'L':\r\n                    case 'd':\r\n                    case 'm':\r\n                    case 's':\r\n                    case 'h':\r\n                    case 'H':\r\n                    case 'f':\r\n                        canUpdate = true;\r\n                        if ((char === 'M' || char === 'L') && len > 2) {\r\n                            var monthData = void 0;\r\n                            if (isBlazor()) {\r\n                                /* tslint:disable no-any */\r\n                                monthData = getValue('months.' + base.monthIndex[len], dependable.dateObject);\r\n                            }\r\n                            else {\r\n                                /* tslint:disable no-any */\r\n                                monthData = dependable.dateObject[month][standalone][base.monthIndex[len]];\r\n                            }\r\n                            // tslint:disable-next-line\r\n                            parseOptions[charKey] = parser.reverseObject(monthData);\r\n                            /* tslint:disable no-any */\r\n                            regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + ')';\r\n                        }\r\n                        else if (char === 'f') {\r\n                            if (len > 3) {\r\n                                continue;\r\n                            }\r\n                            isNumber = true;\r\n                            regexString += '(' + nRegx + nRegx + '?' + nRegx + '?' + ')';\r\n                        }\r\n                        else {\r\n                            isNumber = true;\r\n                            regexString += '(' + nRegx + nRegx + optional + ')';\r\n                        }\r\n                        if (char === 'h') {\r\n                            parseOptions.hour12 = true;\r\n                        }\r\n                        break;\r\n                    case 'W':\r\n                        var opt = len === 1 ? '?' : '';\r\n                        regexString += '(' + nRegx + opt + nRegx + ')';\r\n                        break;\r\n                    case 'y':\r\n                        canUpdate = isNumber = true;\r\n                        if (len === 2) {\r\n                            regexString += '(' + nRegx + nRegx + ')';\r\n                        }\r\n                        else {\r\n                            regexString += '(' + nRegx + '{' + len + ',})';\r\n                        }\r\n                        break;\r\n                    case 'a':\r\n                        canUpdate = true;\r\n                        var periodValur = isBlazor() ?\r\n                            getValue('dayPeriods', dependable.dateObject) :\r\n                            getValue('dayPeriods.format.wide', dependable.dateObject);\r\n                        parseOptions[charKey] = parser.reverseObject(periodValur);\r\n                        regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + ')';\r\n                        break;\r\n                    case 'G':\r\n                        canUpdate = true;\r\n                        var eText = (len <= 3) ? 'eraAbbr' : (len === 4) ? 'eraNames' : 'eraNarrow';\r\n                        parseOptions[charKey] = parser.reverseObject(isBlazor() ?\r\n                            getValue('eras', dependable.dateObject) : getValue('eras.' + eText, dependable.dateObject));\r\n                        regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + '?)';\r\n                        break;\r\n                    case 'z':\r\n                        var tval = new Date().getTimezoneOffset();\r\n                        canUpdate = (tval !== 0);\r\n                        parseOptions[charKey] = getValue('dates.timeZoneNames', dependable.parserObject);\r\n                        var tzone = parseOptions[charKey];\r\n                        hourOnly = (len < 4);\r\n                        var hpattern = hourOnly ? '+H;-H' : tzone.hourFormat;\r\n                        hpattern = hpattern.replace(/:/g, numMapper.timeSeparator);\r\n                        regexString += '(' + this.parseTimeZoneRegx(hpattern, tzone, nRegx) + ')?';\r\n                        isgmtTraversed = true;\r\n                        zCorrectTemp = hourOnly ? 6 : 12;\r\n                        break;\r\n                    case '\\'':\r\n                        var iString = str.replace(/\\'/g, '');\r\n                        regexString += '(' + iString + ')?';\r\n                        break;\r\n                    default:\r\n                        regexString += '([\\\\D])';\r\n                        break;\r\n                }\r\n                if (canUpdate) {\r\n                    parseOptions.evalposition[charKey] = { isNumber: isNumber, pos: i + 1 + gmtCorrection, hourOnly: hourOnly };\r\n                }\r\n                if (i === length_1 - 1 && !isNullOrUndefined(regexString)) {\r\n                    parseOptions.parserRegex = new RegExp('^' + regexString + '$', 'i');\r\n                }\r\n            }\r\n        }\r\n        return function (value) {\r\n            var parsedDateParts = _this.internalDateParse(value, parseOptions, numOptions);\r\n            if (isNullOrUndefined(parsedDateParts) || !Object.keys(parsedDateParts).length) {\r\n                return null;\r\n            }\r\n            if (parseOptions.isIslamic) {\r\n                var dobj = {};\r\n                var tYear = parsedDateParts.year;\r\n                var tDate = parsedDateParts.day;\r\n                var tMonth = parsedDateParts.month;\r\n                var ystrig = tYear ? (tYear + '') : '';\r\n                var is2DigitYear = (ystrig.length === 2);\r\n                if (!tYear || !tMonth || !tDate || is2DigitYear) {\r\n                    dobj = HijriParser.getHijriDate(new Date());\r\n                }\r\n                if (is2DigitYear) {\r\n                    tYear = parseInt((dobj.year + '').slice(0, 2) + ystrig, 10);\r\n                }\r\n                // tslint:disable-next-line\r\n                var dateObject = HijriParser.toGregorian(tYear || dobj.year, tMonth || dobj.month, tDate || dobj.date);\r\n                parsedDateParts.year = dateObject.getFullYear();\r\n                parsedDateParts.month = dateObject.getMonth() + 1;\r\n                parsedDateParts.day = dateObject.getDate();\r\n            }\r\n            return _this.getDateObject(parsedDateParts);\r\n        };\r\n    };\r\n    /* tslint:disable */\r\n    /**\r\n     * Returns date object for provided date options\r\n     * @param {DateParts} options\r\n     * @param {Date} value\r\n     * @returns {Date}\r\n     */\r\n    DateParser.getDateObject = function (options, value) {\r\n        var res = value || new Date();\r\n        res.setMilliseconds(0);\r\n        var tKeys = ['hour', 'minute', 'second', 'milliseconds', 'month', 'day'];\r\n        var y = options.year;\r\n        var desig = options.designator;\r\n        var tzone = options.timeZone;\r\n        if (!isUndefined(y)) {\r\n            var len = (y + '').length;\r\n            if (len <= 2) {\r\n                var century = Math.floor(res.getFullYear() / 100) * 100;\r\n                y += century;\r\n            }\r\n            res.setFullYear(y);\r\n        }\r\n        for (var _i = 0, tKeys_1 = tKeys; _i < tKeys_1.length; _i++) {\r\n            var key = tKeys_1[_i];\r\n            var tValue = options[key];\r\n            if (isUndefined(tValue) && key === \"day\") {\r\n                res.setDate(1);\r\n            }\r\n            if (!isUndefined(tValue)) {\r\n                if (key === 'month') {\r\n                    tValue -= 1;\r\n                    if (tValue < 0 || tValue > 11) {\r\n                        return new Date('invalid');\r\n                    }\r\n                    var pDate = res.getDate();\r\n                    res.setDate(1);\r\n                    res[timeSetter[key]](tValue);\r\n                    var lDate = new Date(res.getFullYear(), tValue + 1, 0).getDate();\r\n                    res.setDate(pDate < lDate ? pDate : lDate);\r\n                }\r\n                else {\r\n                    if (key === 'day') {\r\n                        var lastDay = new Date(res.getFullYear(), res.getMonth() + 1, 0).getDate();\r\n                        if ((tValue < 1 || tValue > lastDay)) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                    res[timeSetter[key]](tValue);\r\n                }\r\n            }\r\n        }\r\n        if (!isUndefined(desig)) {\r\n            var hour = res.getHours();\r\n            if (desig === 'pm') {\r\n                res.setHours(hour + (hour === 12 ? 0 : 12));\r\n            }\r\n            else if (hour === 12) {\r\n                res.setHours(0);\r\n            }\r\n        }\r\n        if (!isUndefined(tzone)) {\r\n            var tzValue = tzone - res.getTimezoneOffset();\r\n            if (tzValue !== 0) {\r\n                res.setMinutes(res.getMinutes() + tzValue);\r\n            }\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Returns date parsing options for provided value along with parse and numeric options\r\n     * @param {string} value\r\n     * @param {ParseOptions} parseOptions\r\n     * @param {NumericOptions} num\r\n     * @returns {DateParts}\r\n     */\r\n    DateParser.internalDateParse = function (value, parseOptions, num) {\r\n        var matches = value.match(parseOptions.parserRegex);\r\n        var retOptions = { 'hour': 0, 'minute': 0, 'second': 0 };\r\n        var nRegx = num.numericRegex;\r\n        if (isNullOrUndefined(matches)) {\r\n            return null;\r\n        }\r\n        else {\r\n            var props = Object.keys(parseOptions.evalposition);\r\n            for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {\r\n                var prop = props_1[_i];\r\n                var curObject = parseOptions.evalposition[prop];\r\n                var matchString = matches[curObject.pos];\r\n                if (curObject.isNumber) {\r\n                    retOptions[prop] = this.internalNumberParser(matchString, num);\r\n                }\r\n                else {\r\n                    if (prop === 'timeZone' && !isUndefined(matchString)) {\r\n                        var pos = curObject.pos;\r\n                        var val = void 0;\r\n                        var tmatch = matches[pos + 1];\r\n                        var flag = !isUndefined(tmatch);\r\n                        if (curObject.hourOnly) {\r\n                            val = this.getZoneValue(flag, tmatch, matches[pos + 4], num) * 60;\r\n                        }\r\n                        else {\r\n                            val = this.getZoneValue(flag, tmatch, matches[pos + 7], num) * 60;\r\n                            val += this.getZoneValue(flag, matches[pos + 4], matches[pos + 10], num);\r\n                        }\r\n                        if (!isNullOrUndefined(val)) {\r\n                            retOptions[prop] = val;\r\n                        }\r\n                    }\r\n                    else {\r\n                        matchString = ((prop === 'month') && (!parseOptions.isIslamic) && (parseOptions.culture === 'en' || parseOptions.culture === 'en-GB' || parseOptions.culture === 'en-US'))\r\n                            ? matchString[0].toUpperCase() + matchString.substring(1).toLowerCase() : matchString;\r\n                        retOptions[prop] = parseOptions[prop][matchString];\r\n                    }\r\n                }\r\n            }\r\n            if (parseOptions.hour12) {\r\n                retOptions.hour12 = true;\r\n            }\r\n        }\r\n        return retOptions;\r\n    };\r\n    /**\r\n     * Returns parsed number for provided Numeric string and Numeric Options\r\n     * @param {string} value\r\n     * @param {NumericOptions} option\r\n     * @returns {number}\r\n     */\r\n    DateParser.internalNumberParser = function (value, option) {\r\n        value = parser.convertValueParts(value, option.numberParseRegex, option.numericPair);\r\n        if (latnRegex.test(value)) {\r\n            return +value;\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Returns parsed time zone RegExp for provided hour format and time zone\r\n     * @param {string} hourFormat\r\n     * @param {base.TimeZoneOptions} tZone\r\n     * @param {string} nRegex\r\n     * @returns {string}\r\n     */\r\n    DateParser.parseTimeZoneRegx = function (hourFormat, tZone, nRegex) {\r\n        var pattern = tZone.gmtFormat;\r\n        var ret;\r\n        var result;\r\n        var cRegex = '(' + nRegex + ')' + '(' + nRegex + ')';\r\n        var splitStr;\r\n        ret = hourFormat.replace('+', '\\\\+');\r\n        if (hourFormat.indexOf('HH') !== -1) {\r\n            ret = ret.replace(/HH|mm/g, '(' + cRegex + ')');\r\n        }\r\n        else {\r\n            ret = ret.replace(/H|m/g, '(' + cRegex + '?)');\r\n        }\r\n        splitStr = (ret.split(';').map(function (str) {\r\n            return pattern.replace('{0}', str);\r\n        }));\r\n        ret = splitStr.join('|') + '|' + tZone.gmtZeroFormat;\r\n        return ret;\r\n    };\r\n    /**\r\n     * Returns zone based value.\r\n     * @param {boolean} flag\r\n     * @param {string} val1\r\n     * @param {string} val2\r\n     * @param {NumericOptions} num\r\n     * @returns {number}\r\n     */\r\n    DateParser.getZoneValue = function (flag, val1, val2, num) {\r\n        var ival = flag ? val1 : val2;\r\n        if (!ival) {\r\n            return 0;\r\n        }\r\n        var value = this.internalNumberParser(ival, num);\r\n        if (flag) {\r\n            return -value;\r\n        }\r\n        return value;\r\n    };\r\n    return DateParser;\r\n}());\r\nexport { DateParser };\r\n/* tslint:enable */\r\n"]},"metadata":{},"sourceType":"module"}