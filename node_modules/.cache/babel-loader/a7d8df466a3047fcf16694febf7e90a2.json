{"ast":null,"code":"import dateutil from './dateutil';\nimport IterResult from './iterresult';\nimport CallbackIterResult from './callbackiterresult';\nimport { Frequency } from './types';\nimport { parseOptions, initializeOptions } from './parseoptions';\nimport { parseString } from './parsestring';\nimport { optionsToString } from './optionstostring';\nimport { Cache } from './cache';\nimport { Weekday } from './weekday';\nimport { iter } from './iter/index';\n\nvar getnlp = function () {\n  // Lazy, runtime import to avoid circular refs.\n  if (!getnlp._nlp) {\n    getnlp._nlp = require('./nlp');\n  }\n\n  return getnlp._nlp;\n}; // =============================================================================\n// RRule\n// =============================================================================\n\n\nexport var Days = {\n  MO: new Weekday(0),\n  TU: new Weekday(1),\n  WE: new Weekday(2),\n  TH: new Weekday(3),\n  FR: new Weekday(4),\n  SA: new Weekday(5),\n  SU: new Weekday(6)\n};\nexport var DEFAULT_OPTIONS = {\n  freq: Frequency.YEARLY,\n  dtstart: null,\n  interval: 1,\n  wkst: Days.MO,\n  count: null,\n  until: null,\n  tzid: null,\n  bysetpos: null,\n  bymonth: null,\n  bymonthday: null,\n  bynmonthday: null,\n  byyearday: null,\n  byweekno: null,\n  byweekday: null,\n  bynweekday: null,\n  byhour: null,\n  byminute: null,\n  bysecond: null,\n  byeaster: null\n};\nexport var defaultKeys = Object.keys(DEFAULT_OPTIONS);\n/**\r\n *\r\n * @param {Options?} options - see <http://labix.org/python-dateutil/#head-cf004ee9a75592797e076752b2a889c10f445418>\r\n *        The only required option is `freq`, one of RRule.YEARLY, RRule.MONTHLY, ...\r\n * @constructor\r\n */\n\nvar RRule =\n/** @class */\nfunction () {\n  function RRule(options, noCache) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (noCache === void 0) {\n      noCache = false;\n    } // RFC string\n\n\n    this._cache = noCache ? null : new Cache(); // used by toString()\n\n    this.origOptions = initializeOptions(options);\n    var parsedOptions = parseOptions(options).parsedOptions;\n    this.options = parsedOptions;\n  }\n\n  RRule.parseText = function (text, language) {\n    return getnlp().parseText(text, language);\n  };\n\n  RRule.fromText = function (text, language) {\n    return getnlp().fromText(text, language);\n  };\n\n  RRule.fromString = function (str) {\n    return new RRule(RRule.parseString(str) || undefined);\n  };\n\n  RRule.prototype._iter = function (iterResult) {\n    return iter(iterResult, this.options);\n  };\n\n  RRule.prototype._cacheGet = function (what, args) {\n    if (!this._cache) return false;\n    return this._cache._cacheGet(what, args);\n  };\n\n  RRule.prototype._cacheAdd = function (what, value, args) {\n    if (!this._cache) return;\n    return this._cache._cacheAdd(what, value, args);\n  };\n  /**\r\n   * @param {Function} iterator - optional function that will be called\r\n   *                   on each date that is added. It can return false\r\n   *                   to stop the iteration.\r\n   * @return Array containing all recurrences.\r\n   */\n\n\n  RRule.prototype.all = function (iterator) {\n    if (iterator) {\n      return this._iter(new CallbackIterResult('all', {}, iterator));\n    }\n\n    var result = this._cacheGet('all');\n\n    if (result === false) {\n      result = this._iter(new IterResult('all', {}));\n\n      this._cacheAdd('all', result);\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns all the occurrences of the rrule between after and before.\r\n   * The inc keyword defines what happens if after and/or before are\r\n   * themselves occurrences. With inc == True, they will be included in the\r\n   * list, if they are found in the recurrence set.\r\n   * @return Array\r\n   */\n\n\n  RRule.prototype.between = function (after, before, inc, iterator) {\n    if (inc === void 0) {\n      inc = false;\n    }\n\n    if (!dateutil.isValidDate(after) || !dateutil.isValidDate(before)) throw new Error('Invalid date passed in to RRule.between');\n    var args = {\n      before: before,\n      after: after,\n      inc: inc\n    };\n\n    if (iterator) {\n      return this._iter(new CallbackIterResult('between', args, iterator));\n    }\n\n    var result = this._cacheGet('between', args);\n\n    if (result === false) {\n      result = this._iter(new IterResult('between', args));\n\n      this._cacheAdd('between', result, args);\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns the last recurrence before the given datetime instance.\r\n   * The inc keyword defines what happens if dt is an occurrence.\r\n   * With inc == True, if dt itself is an occurrence, it will be returned.\r\n   * @return Date or null\r\n   */\n\n\n  RRule.prototype.before = function (dt, inc) {\n    if (inc === void 0) {\n      inc = false;\n    }\n\n    if (!dateutil.isValidDate(dt)) throw new Error('Invalid date passed in to RRule.before');\n    var args = {\n      dt: dt,\n      inc: inc\n    };\n\n    var result = this._cacheGet('before', args);\n\n    if (result === false) {\n      result = this._iter(new IterResult('before', args));\n\n      this._cacheAdd('before', result, args);\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns the first recurrence after the given datetime instance.\r\n   * The inc keyword defines what happens if dt is an occurrence.\r\n   * With inc == True, if dt itself is an occurrence, it will be returned.\r\n   * @return Date or null\r\n   */\n\n\n  RRule.prototype.after = function (dt, inc) {\n    if (inc === void 0) {\n      inc = false;\n    }\n\n    if (!dateutil.isValidDate(dt)) throw new Error('Invalid date passed in to RRule.after');\n    var args = {\n      dt: dt,\n      inc: inc\n    };\n\n    var result = this._cacheGet('after', args);\n\n    if (result === false) {\n      result = this._iter(new IterResult('after', args));\n\n      this._cacheAdd('after', result, args);\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns the number of recurrences in this set. It will have go trough\r\n   * the whole recurrence, if this hasn't been done before.\r\n   */\n\n\n  RRule.prototype.count = function () {\n    return this.all().length;\n  };\n  /**\r\n   * Converts the rrule into its string representation\r\n   * @see <http://www.ietf.org/rfc/rfc2445.txt>\r\n   * @return String\r\n   */\n\n\n  RRule.prototype.toString = function () {\n    return optionsToString(this.origOptions);\n  };\n  /**\r\n   * Will convert all rules described in nlp:ToText\r\n   * to text.\r\n   */\n\n\n  RRule.prototype.toText = function (gettext, language, dateFormatter) {\n    return getnlp().toText(this, gettext, language, dateFormatter);\n  };\n\n  RRule.prototype.isFullyConvertibleToText = function () {\n    return getnlp().isFullyConvertible(this);\n  };\n  /**\r\n   * @return a RRule instance with the same freq and options\r\n   *          as this one (cache is not cloned)\r\n   */\n\n\n  RRule.prototype.clone = function () {\n    return new RRule(this.origOptions);\n  }; // RRule class 'constants'\n\n\n  RRule.FREQUENCIES = ['YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY', 'HOURLY', 'MINUTELY', 'SECONDLY'];\n  RRule.YEARLY = Frequency.YEARLY;\n  RRule.MONTHLY = Frequency.MONTHLY;\n  RRule.WEEKLY = Frequency.WEEKLY;\n  RRule.DAILY = Frequency.DAILY;\n  RRule.HOURLY = Frequency.HOURLY;\n  RRule.MINUTELY = Frequency.MINUTELY;\n  RRule.SECONDLY = Frequency.SECONDLY;\n  RRule.MO = Days.MO;\n  RRule.TU = Days.TU;\n  RRule.WE = Days.WE;\n  RRule.TH = Days.TH;\n  RRule.FR = Days.FR;\n  RRule.SA = Days.SA;\n  RRule.SU = Days.SU;\n  RRule.parseString = parseString;\n  RRule.optionsToString = optionsToString;\n  return RRule;\n}();\n\nexport default RRule;","map":{"version":3,"sources":["../../../src/rrule.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import dateutil from './dateutil';\r\nimport IterResult from './iterresult';\r\nimport CallbackIterResult from './callbackiterresult';\r\nimport { Frequency } from './types';\r\nimport { parseOptions, initializeOptions } from './parseoptions';\r\nimport { parseString } from './parsestring';\r\nimport { optionsToString } from './optionstostring';\r\nimport { Cache } from './cache';\r\nimport { Weekday } from './weekday';\r\nimport { iter } from './iter/index';\r\nvar getnlp = function () {\r\n    // Lazy, runtime import to avoid circular refs.\r\n    if (!getnlp._nlp) {\r\n        getnlp._nlp = require('./nlp');\r\n    }\r\n    return getnlp._nlp;\r\n};\r\n// =============================================================================\r\n// RRule\r\n// =============================================================================\r\nexport var Days = {\r\n    MO: new Weekday(0),\r\n    TU: new Weekday(1),\r\n    WE: new Weekday(2),\r\n    TH: new Weekday(3),\r\n    FR: new Weekday(4),\r\n    SA: new Weekday(5),\r\n    SU: new Weekday(6)\r\n};\r\nexport var DEFAULT_OPTIONS = {\r\n    freq: Frequency.YEARLY,\r\n    dtstart: null,\r\n    interval: 1,\r\n    wkst: Days.MO,\r\n    count: null,\r\n    until: null,\r\n    tzid: null,\r\n    bysetpos: null,\r\n    bymonth: null,\r\n    bymonthday: null,\r\n    bynmonthday: null,\r\n    byyearday: null,\r\n    byweekno: null,\r\n    byweekday: null,\r\n    bynweekday: null,\r\n    byhour: null,\r\n    byminute: null,\r\n    bysecond: null,\r\n    byeaster: null\r\n};\r\nexport var defaultKeys = Object.keys(DEFAULT_OPTIONS);\r\n/**\r\n *\r\n * @param {Options?} options - see <http://labix.org/python-dateutil/#head-cf004ee9a75592797e076752b2a889c10f445418>\r\n *        The only required option is `freq`, one of RRule.YEARLY, RRule.MONTHLY, ...\r\n * @constructor\r\n */\r\nvar RRule = /** @class */ (function () {\r\n    function RRule(options, noCache) {\r\n        if (options === void 0) { options = {}; }\r\n        if (noCache === void 0) { noCache = false; }\r\n        // RFC string\r\n        this._cache = noCache ? null : new Cache();\r\n        // used by toString()\r\n        this.origOptions = initializeOptions(options);\r\n        var parsedOptions = parseOptions(options).parsedOptions;\r\n        this.options = parsedOptions;\r\n    }\r\n    RRule.parseText = function (text, language) {\r\n        return getnlp().parseText(text, language);\r\n    };\r\n    RRule.fromText = function (text, language) {\r\n        return getnlp().fromText(text, language);\r\n    };\r\n    RRule.fromString = function (str) {\r\n        return new RRule(RRule.parseString(str) || undefined);\r\n    };\r\n    RRule.prototype._iter = function (iterResult) {\r\n        return iter(iterResult, this.options);\r\n    };\r\n    RRule.prototype._cacheGet = function (what, args) {\r\n        if (!this._cache)\r\n            return false;\r\n        return this._cache._cacheGet(what, args);\r\n    };\r\n    RRule.prototype._cacheAdd = function (what, value, args) {\r\n        if (!this._cache)\r\n            return;\r\n        return this._cache._cacheAdd(what, value, args);\r\n    };\r\n    /**\r\n     * @param {Function} iterator - optional function that will be called\r\n     *                   on each date that is added. It can return false\r\n     *                   to stop the iteration.\r\n     * @return Array containing all recurrences.\r\n     */\r\n    RRule.prototype.all = function (iterator) {\r\n        if (iterator) {\r\n            return this._iter(new CallbackIterResult('all', {}, iterator));\r\n        }\r\n        var result = this._cacheGet('all');\r\n        if (result === false) {\r\n            result = this._iter(new IterResult('all', {}));\r\n            this._cacheAdd('all', result);\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Returns all the occurrences of the rrule between after and before.\r\n     * The inc keyword defines what happens if after and/or before are\r\n     * themselves occurrences. With inc == True, they will be included in the\r\n     * list, if they are found in the recurrence set.\r\n     * @return Array\r\n     */\r\n    RRule.prototype.between = function (after, before, inc, iterator) {\r\n        if (inc === void 0) { inc = false; }\r\n        if (!dateutil.isValidDate(after) || !dateutil.isValidDate(before))\r\n            throw new Error('Invalid date passed in to RRule.between');\r\n        var args = {\r\n            before: before,\r\n            after: after,\r\n            inc: inc\r\n        };\r\n        if (iterator) {\r\n            return this._iter(new CallbackIterResult('between', args, iterator));\r\n        }\r\n        var result = this._cacheGet('between', args);\r\n        if (result === false) {\r\n            result = this._iter(new IterResult('between', args));\r\n            this._cacheAdd('between', result, args);\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Returns the last recurrence before the given datetime instance.\r\n     * The inc keyword defines what happens if dt is an occurrence.\r\n     * With inc == True, if dt itself is an occurrence, it will be returned.\r\n     * @return Date or null\r\n     */\r\n    RRule.prototype.before = function (dt, inc) {\r\n        if (inc === void 0) { inc = false; }\r\n        if (!dateutil.isValidDate(dt))\r\n            throw new Error('Invalid date passed in to RRule.before');\r\n        var args = { dt: dt, inc: inc };\r\n        var result = this._cacheGet('before', args);\r\n        if (result === false) {\r\n            result = this._iter(new IterResult('before', args));\r\n            this._cacheAdd('before', result, args);\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Returns the first recurrence after the given datetime instance.\r\n     * The inc keyword defines what happens if dt is an occurrence.\r\n     * With inc == True, if dt itself is an occurrence, it will be returned.\r\n     * @return Date or null\r\n     */\r\n    RRule.prototype.after = function (dt, inc) {\r\n        if (inc === void 0) { inc = false; }\r\n        if (!dateutil.isValidDate(dt))\r\n            throw new Error('Invalid date passed in to RRule.after');\r\n        var args = { dt: dt, inc: inc };\r\n        var result = this._cacheGet('after', args);\r\n        if (result === false) {\r\n            result = this._iter(new IterResult('after', args));\r\n            this._cacheAdd('after', result, args);\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Returns the number of recurrences in this set. It will have go trough\r\n     * the whole recurrence, if this hasn't been done before.\r\n     */\r\n    RRule.prototype.count = function () {\r\n        return this.all().length;\r\n    };\r\n    /**\r\n     * Converts the rrule into its string representation\r\n     * @see <http://www.ietf.org/rfc/rfc2445.txt>\r\n     * @return String\r\n     */\r\n    RRule.prototype.toString = function () {\r\n        return optionsToString(this.origOptions);\r\n    };\r\n    /**\r\n     * Will convert all rules described in nlp:ToText\r\n     * to text.\r\n     */\r\n    RRule.prototype.toText = function (gettext, language, dateFormatter) {\r\n        return getnlp().toText(this, gettext, language, dateFormatter);\r\n    };\r\n    RRule.prototype.isFullyConvertibleToText = function () {\r\n        return getnlp().isFullyConvertible(this);\r\n    };\r\n    /**\r\n     * @return a RRule instance with the same freq and options\r\n     *          as this one (cache is not cloned)\r\n     */\r\n    RRule.prototype.clone = function () {\r\n        return new RRule(this.origOptions);\r\n    };\r\n    // RRule class 'constants'\r\n    RRule.FREQUENCIES = [\r\n        'YEARLY',\r\n        'MONTHLY',\r\n        'WEEKLY',\r\n        'DAILY',\r\n        'HOURLY',\r\n        'MINUTELY',\r\n        'SECONDLY'\r\n    ];\r\n    RRule.YEARLY = Frequency.YEARLY;\r\n    RRule.MONTHLY = Frequency.MONTHLY;\r\n    RRule.WEEKLY = Frequency.WEEKLY;\r\n    RRule.DAILY = Frequency.DAILY;\r\n    RRule.HOURLY = Frequency.HOURLY;\r\n    RRule.MINUTELY = Frequency.MINUTELY;\r\n    RRule.SECONDLY = Frequency.SECONDLY;\r\n    RRule.MO = Days.MO;\r\n    RRule.TU = Days.TU;\r\n    RRule.WE = Days.WE;\r\n    RRule.TH = Days.TH;\r\n    RRule.FR = Days.FR;\r\n    RRule.SA = Days.SA;\r\n    RRule.SU = Days.SU;\r\n    RRule.parseString = parseString;\r\n    RRule.optionsToString = optionsToString;\r\n    return RRule;\r\n}());\r\nexport default RRule;\r\n//# sourceMappingURL=rrule.js.map"]},"metadata":{},"sourceType":"module"}